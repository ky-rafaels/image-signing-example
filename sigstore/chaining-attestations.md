Chaining attestations between container image builds involves creating a sequence of attestations where each build’s output (an image) carries verifiable metadata (e.g., provenance, SBOM) that can be linked to subsequent builds, ensuring a traceable and secure supply chain. This is particularly useful in multi-stage or dependent builds, where one image serves as the base for another, and you want to maintain a chain of trust across the process. Below, I’ll explain how to achieve this, focusing on practical approaches using tools like Docker BuildKit, Cosign, and GitHub Actions, which are commonly used for attestation generation and verification.

### Key Concepts
- **Attestations**: Metadata attached to a container image, such as a Software Bill of Materials (SBOM) or provenance (build instructions, source info), typically in in-toto format (JSON) and signed for authenticity.
- **Chaining**: Ensuring that each build’s attestation references its inputs (e.g., base images, dependencies) and that downstream builds inherit or reference the attestations of their dependencies, forming a verifiable trail.
- **Tools**:
  - **Docker BuildKit**: Generates SBOM and provenance attestations during builds.
  - **Cosign**: Signs images and attestations, associating them with images in a registry.
  - **GitHub Actions**: Automates attestation creation in CI/CD pipelines.
  - **in-toto**: A framework for securing software supply chains, used to structure attestations.

### Approaches to Chain Attestations

#### 1. **Using Docker BuildKit with Provenance and SBOM Attestations**
BuildKit (Docker’s build engine) can generate attestations during image builds, which can be chained across dependent builds by ensuring each image’s attestations are preserved and referenced.

- **Step 1: Generate Attestations for the First Build**
  Suppose you have a base image built from `Dockerfile-base`:
  ```dockerfile
  FROM ubuntu:20.04
  RUN apt-get update && apt-get install -y curl
  ```
  Build the image with attestations:
  ```bash
  docker buildx build \
    --tag myregistry/base:latest \
    --attest type=provenance,mode=max \
    --attest type=sbom \
    --push .
  ```
  - `--attest type=provenance,mode=max`: Includes detailed build provenance (e.g., Dockerfile, build args, source).
  - `--attest type=sbom`: Generates an SBOM listing packages (e.g., curl, dependencies).
  - `--push`: Ensures the image and attestations are stored in a registry (required for attestation preservation).

  The resulting image (`myregistry/base:latest`) has attestations attached as OCI manifest objects, stored in the registry.

- **Step 2: Use the Base Image in a Second Build**
  Create a dependent image with `Dockerfile-app`:
  ```dockerfile
  FROM myregistry/base:latest
  COPY app.py /app/
  RUN pip install flask
  CMD ["python", "/app/app.py"]
  ```
  Build this image, also generating attestations:
  ```bash
  docker buildx build \
    --tag myregistry/app:latest \
    --attest type=provenance,mode=max \
    --attest type=sbom \
    --push .
  ```

- **Chaining Mechanism**:
  - The provenance attestation for `myregistry/app:latest` includes the base image (`myregistry/base:latest`) as a material (via its digest, e.g., `sha256:abc123...`).
  - The SBOM for `myregistry/app:latest` lists its own packages (e.g., Flask) but doesn’t automatically include the base image’s SBOM. To chain SBOMs, you’d need to aggregate them manually or use a tool (see below).
  - BuildKit’s provenance records the dependency on the base image’s digest, ensuring traceability. You can inspect this with:
    ```bash
    docker buildx imagetools inspect myregistry/app:latest --format '{{ json .Provenance.SLSA }}'
    ```
    This shows the `materials` field, including the base image’s digest.

- **Step 3: Verify the Chain**
  To verify the chain, check both images’ attestations:
  ```bash
  docker buildx imagetools inspect myregistry/base:latest --format '{{ json .Provenance.SLSA }}'
  docker buildx imagetools inspect myregistry/app:latest --format '{{ json .Provenance.SLSA }}'
  ```
  The app image’s provenance should reference the base image’s digest, linking the builds. For SBOMs, you’d need to combine them manually or use a tool like `syft` to aggregate dependencies across layers.

#### 2. **Using Cosign for Signed Attestations**
Cosign (part of Sigstore) allows signing images and attaching custom attestations, which can explicitly link builds.

- **Step 1: Sign and Attest the Base Image**
  Build and push the base image as above, then sign it:
  ```bash
  cosign sign myregistry/base:latest
  ```
  Create a custom attestation (e.g., for provenance or SBOM):
  ```bash
  cosign attest \
    --key cosign.key \
    --predicate image.sbom.json \
    --type spdx \
    myregistry/base:latest
  ```
  - `image.sbom.json`: An SBOM file (e.g., generated by `syft`).
  - This creates a signed attestation stored in the registry as `myregistry/base:latest.att`.

- **Step 2: Reference in the Second Build**
  Build the app image using `myregistry/base:latest`. After pushing, create its attestation, explicitly referencing the base image’s attestation:
  ```bash
  cosign attest \
    --key cosign.key \
    --predicate app.sbom.json \
    --type spdx \
    myregistry/app:latest
  ```
  To chain explicitly, include the base image’s attestation digest in a custom predicate. For example, create `app.provenance.json`:
  ```json
  {
    "base_image": "myregistry/base:latest@sha256:abc123...",
    "base_attestation_digest": "sha256:def456...",
    "build_details": "..."
  }
  ```
  Then attest:
  ```bash
  cosign attest \
    --key cosign.key \
    --predicate app.provenance.json \
    --type custom \
    myregistry/app:latest
  ```

- **Chaining Mechanism**:
  - Cosign’s attestations are linked via digests in the registry. The app image’s attestation references the base image’s digest and attestation, forming a chain.
  - Verification checks the signatures and digests:
    ```bash
    cosign verify-attestation --key cosign.pub myregistry/app:latest
    cosign verify-attestation --key cosign.pub myregistry/base:latest
    ```

#### 3. **Using GitHub Actions for Automation**
GitHub Actions can automate attestation chaining in a CI/CD pipeline, leveraging actions like `actions/attest-build-provenance`.

- **Step 1: Build and Attest the Base Image**
  Example workflow (`base.yml`):
  ```yaml
  name: Build Base Image
  on:
    push:
      branches: [main]
  jobs:
    build:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        - uses: docker/login-action@v3
          with:
            registry: ghcr.io
            username: ${{ github.actor }}
            password: ${{ secrets.GITHUB_TOKEN }}
        - uses: docker/build-push-action@v5
          with:
            context: .
            file: Dockerfile-base
            push: true
            tags: ghcr.io/${{ github.repository }}/base:latest
            provenance: true
            sbom: true
        - uses: actions/attest-build-provenance@v1
          with:
            subject-name: ghcr.io/${{ github.repository }}/base
            subject-digest: ${{ steps.build.outputs.digest }}
  ```

- **Step 2: Build and Attest the App Image**
  Workflow (`app.yml`):
  ```yaml
  name: Build App Image
  on:
    push:
      branches: [main]
  jobs:
    build:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        - uses: docker/login-action@v3
          with:
            registry: ghcr.io
            username: ${{ github.actor }}
            password: ${{ secrets.GITHUB_TOKEN }}
        - uses: docker/build-push-action@v5
          with:
            context: .
            file: Dockerfile-app
            push: true
            tags: ghcr.io/${{ github.repository }}/app:latest
            provenance: true
            sbom: true
        - uses: actions/attest-build-provenance@v1
          with:
            subject-name: ghcr.io/${{ github.repository }}/app
            subject-digest: ${{ steps.build.outputs.digest }}
  ```

- **Chaining Mechanism**:
  - The `docker/build-push-action` generates provenance linking the app image to the base image (via digest).
  - The `actions/attest-build-provenance` action creates a signed attestation (SLSA v1.0 Build Level 2), stored in GitHub’s registry.
  - To explicitly chain, add a step to fetch the base image’s attestation digest (using `gh attestation`) and include it in the app’s attestation metadata.

- **Verification**:
  Use GitHub CLI to verify:
  ```bash
  gh attestation verify oci://ghcr.io/user/app:latest --owner user
  ```

#### 4. **Manual Chaining with in-toto**
For full control, use the in-toto framework to create custom attestations that explicitly link builds.

- **Step 1: Attest the Base Build**
  Create an in-toto attestation for the base image:
  ```bash
  in-toto-run \
    --step-name build-base \
    --products myregistry/base:latest \
    --record-stream \
    -- docker buildx build -t myregistry/base:latest --push .
  ```
  This generates `build-base.attestation.json`, signed with your key.

- **Step 2: Attest the App Build**
  For the app build, reference the base image and its attestation:
  ```bash
  in-toto-run \
    --step-name build-app \
    --materials myregistry/base:latest \
    --products myregistry/app:latest \
    --record-stream \
    -- docker buildx build -t myregistry/app:latest --push .
  ```
  Manually edit `build-app.attestation.json` to include the base attestation’s digest or URI.

- **Chaining Mechanism**:
  - The `materials` field in the app’s attestation lists the base image’s digest.
  - Custom predicates can include the base attestation’s digest, forming an explicit link.
  - Verify with:
    ```bash
    in-toto-verify --layout pipeline.layout --key public.key
    ```

### Best Practices
- **Use Digests**: Always reference images by their SHA256 digest (e.g., `myregistry/base@sha256:abc123...`) to ensure immutability and precise linking.
- **Sign Attestations**: Use tools like Cosign or in-toto to sign attestations, preventing tampering.
- **Store in Registry**: Push images and attestations to an OCI-compliant registry to preserve metadata (local Docker stores may drop attestations).
- **Aggregate SBOMs**: If chaining SBOMs, use tools like `syft` or `spdx-tools` to merge base and app SBOMs for a complete view.
- **Automate in CI/CD**: Use GitHub Actions or similar to streamline attestation generation and verification.

### Challenges
- **Attestation Storage**: Local builds with Docker’s default store lose attestations unless you use `--push` or enable the containerd store.
- **SBOM Aggregation**: BuildKit doesn’t automatically combine base and derived SBOMs; you may need custom scripts.
- **Tool Interoperability**: Ensure tools (e.g., Cosign, BuildKit) use compatible formats (e.g., in-toto, SPDX).

In your Keycloak context, chaining attestations could secure a containerized Keycloak deployment by linking the Keycloak image to a trusted base (e.g., a hardened Java image). For example, attest the Java base image with BuildKit, then attest the Keycloak image, ensuring the provenance references the base’s digest. This aligns with FIPS compliance (e.g., using EdDSA from FIPS 186-5) if you’re using Go Boring Crypto or a FIPS-validated module.
